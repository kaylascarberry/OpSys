/*
Seminar 2: Team Twin Terminal
Lottery Scheduler
*/

/*Necessary Libraries*/
#include <stdio.h>      // Brings declarations for printf/scanf; no runtime memory allocate here.
#include <stdlib.h>     // Brings malloc/free, rand/srand; no runtime memory allocate here.
#include <time.h>       // Brings time(); used to seed RNG; no allocation here.

/*Global Definitions*/
// Length of time the process runs, in this program, this is how much of the process's size 
// is reduced when its ticket is picked
#define UNITTIME 1      // Preprocessor macro: replaced at compile time; value is embedded in code section.
int next_pid = 1;       // Global variable in static storage; zero-inited by loader, then set to 1 before main().

/* -------------------- Data Structures -------------------- */

typedef struct _Process {
    int pid;        // Process ID; stored inside each Process node allocated on the HEAP.
    int tickets;    // Ticket count; HEAP field inside the struct.
    int size;       // Remaining work units; HEAP field.
    struct _Process * next; // Pointer to next node in singly linked list (HEAP address or NULL).
} Process;          // 'Process' becomes a type alias; no memory allocated for the typedef itself.

typedef struct _Queue{
    Process* first;     // Pointer to head node (HEAP address) or NULL; this field lives wherever Queue lives.
    int totalTickets;   // Sum of tickets of all nodes currently in the queue; lives inside Queue.
    int count;          // Number of nodes in the queue; lives inside Queue.
} Queue;            // Type alias; no memory created by the typedef itself.

/* -------------------- Functions -------------------- */

/*Function Declaration and Prototyping All Before Main*/
static Queue* create_queue(void) {             // Function in code segment; stack frame allocated on call.
    //make a result variable and allocate some memory to it:
    Queue* q = (Queue*)malloc(sizeof(Queue));  // HEAP: allocates sizeof(Queue) bytes; 'q' is a STACK pointer to it.
    if (!q) return NULL;                       // If allocation failed, return NULL pointer.
    q->first = NULL;    //use -> instead . because it is a pointer
    // Writes into the HEAP block fields through pointer 'q'.
    q->count = 0;                              // Initialize count (HEAP field) to 0.
    q->totalTickets = 0;                       // Initialize totals (HEAP field) to 0.
    return q;                                  // Return HEAP pointer; caller receives it on their STACK.
}

static Process* create_process(int tickets, int size) { // Called to make one HEAP node.
    //dont point * to the process because malloc needs to know how many bytes 
    // are needed for the structure
    Process* p = (Process*)malloc(sizeof(Process)); // HEAP: allocates one Process object; 'p' is a STACK pointer.
    if(!p) return NULL;                      // Return NULL on failure.
    p->pid = next_pid++;    //global variable
    // Reads/writes global 'next_pid' in static storage; post-increments it.
    p->tickets = tickets;                    // Writes caller-provided 'tickets' value into HEAP struct field.
    p->size = size;                          // Writes caller-provided 'size' value into HEAP struct field.
    p->next = NULL;                          // Terminates linkage for now; HEAP field set to NULL.
    return p;                                // Return HEAP pointer to caller (copied to caller's STACK).
}

//adds process to end of q
static int enqueue(Queue* q, Process* p) {    // 'q' and 'p' are STACK pointers to HEAP objects.
    //enqueue is declared as int so if -1 occurs, we know that it failed
    if (!q || !p) return -1;                  // Validate pointers; returns small int on error.

    if (!q->first) {                          // If queue is empty (head link is NULL)...
        q->first = p;   //know that q = 0       // Write HEAP address of 'p' into the 'first' field (HEAP field in *q).
    } else {
        Process* c = q->first;            //create a new local variable 
        // 'c' is a STACK pointer set to the HEAP head node address.
        while (c->next) c = c->next;      //c is current
        // Traverse via HEAP 'next' pointers until we reach last node (where next == NULL).
        c->next = p;                      //
        // Link new node: write HEAP address 'p' into last node’s 'next' field (in HEAP).
    }
    p->next = NULL;                           // Ensure the enqueued node ends the list (HEAP field).
    q->count++; //increment the count          // Increment count (HEAP field inside *q).
    q->totalTickets += p->tickets;            // Add this node’s tickets to total (HEAP field inside *q).
    return 0;                                 // Success code on the STACK return register.
}

//remove from queue and return a process
static Process* dequeue(Queue* q) {
    if(!q) return NULL;  // Null queue pointer → no action.
    if (!q->first) return NULL; //Empty queue → return NULL.

    Process* p = q->first; //create a local variable p to hold the result. 'p' is a STACK pointer to the current HEAP head node.
    q->first = p->next; //make the first element the one next to the first. Overwrite the HEAP 'first' link with the next node’s HEAP address.
    p->next = NULL; //show that there is nothing else after in the q. Detach returned node from list by clearing its HEAP 'next' link.
    q->count--;   //decrement the count. Update HEAP field 'count' in *q.
    q->totalTickets -= p->tickets; //decrement the number of lottery tickets after used. Update total tickets (HEAP field).
    return p; //return the result. Return a HEAP pointer to the removed node; caller owns it (must free when done).  
}

/* Remove target from queue and free it (updates count/totalTickets). */
static void remove_and_free(Queue* q, Process* target) {
    if (!q || !target) return;  // Validate pointers; nothing to do if invalid.

    // Pointer-to-pointer walk: 'pp' is a STACK pointer to the LINK that points to the current node.
    // Initially '&q->first' (address of the head link in the Queue object on HEAP).
    for (Process** pp = &q->first; *pp; pp = &(*pp)->next){
        // Loop condition '*pp': as long as the current link points to a node (non-NULL).
        // Increment 'pp' to address of the next link field: &((*pp)->next).

        if (*pp == target){                   // If the current link points to the target node...
            q->totalTickets -= target->tickets; // Subtract its tickets from queue total (HEAP field).
            q->count--;                       // Decrement queue node count (HEAP field).
            *pp = target->next;               // Splice out: write target->next into the link that pointed to target.
            // If removing head: this writes into q->first (HEAP field). If middle: writes into a prior node’s HEAP 'next'.

            free(target);                     // Free the HEAP memory of the removed Process object; pointer becomes invalid.
            return;                           // Exit; 'pp' is a STACK variable and goes away when function returns.
        }
    }
}

//Print the Q with the process ID, # of tickets, and the size of the process
static void print_queue(const Queue* q) {
    printf("\nPID  Tickets  Size\n");         // String literal in static storage; printed to stdout.
    printf("------------------\n");
    for (const Process* p = q->first; p; p = p->next)
        // 'p' is a STACK pointer iterating over HEAP nodes via 'next' links.
        printf("P%-3d %-7d %-4d\n", p->pid, p->tickets, p->size);
        // Reads HEAP fields and prints them.

    printf("Total tickets: %d | Processes: %d\n", q->totalTickets, q->count);
    // Reads HEAP fields from *q and prints.
}

//NEED HELP COMMENTING THIS
static Process* pick_winner(const Queue* q, int* drawn) {
    if (!q || q->totalTickets <= 0) return NULL;
    // If queue pointer invalid or zero tickets, no winner; return NULL.

    int r = (rand() % q->totalTickets) + 1;   //
    // Draws a pseudo-random int in [1..totalTickets]; 'r' is a STACK int.
    // rand() uses C library internal static state seeded by srand().
    if (drawn) *drawn = r;                    // If caller provided address, store 'r' into caller’s STACK/HEAP int.

    int acc = 0;                              // STACK accumulator for cumulative ticket ranges.
    for (Process* p = q->first; p; p = p->next) {
        // NOTE: 'q' is const, but 'p' is typed non-const here. We only read fields,
        // so conceptually this should be 'const Process* p'; as-is, most compilers tolerate it.
        acc += p->tickets;                    // Add this node’s HEAP 'tickets' to STACK 'acc'.
        if (acc >= r) return p;               // First cumulative >= r wins: return HEAP pointer to winner.
    }
    return NULL;                              // Shouldn’t happen if totals are consistent; defensive.
}

//Lottery Scheduler
static void lottery(Queue* rq, int round) {
    if (rq->count == 0 || rq->totalTickets <= 0) return;
    // If no runnable processes or zero tickets, nothing to do.

    int ticket = -1;                          // STACK variable to hold the drawn ticket number.
    Process* w = pick_winner(rq, &ticket);    // Returns HEAP pointer to winner; writes drawn ticket into 'ticket'.
    if (!w) return;                           // Defensive guard.

    printf("\n-- Round %d --\n", round);
    printf("Drawn ticket: %d (of %d)\n", ticket, rq->totalTickets);
    printf("Winner: P%d (tickets=%d, size=%d)\n", w->pid, w->tickets, w->size);
    // Only reading HEAP fields here; prints the current state.

    // Run winner for fixed work-per-turn
    if (w->size > UNITTIME
) w->size -= UNITTIME
; else w->size = 0;
    // Decrements HEAP 'size' by UNITTIME atomically; awkward line breaks but functionally:
    // if (w->size > UNITTIME) { w->size -= UNITTIME; } else { w->size = 0; }
    // Simulates consuming CPU time.

    // Priority decay: winner loses one ticket
    if (w->tickets > 0) { w->tickets--; rq->totalTickets--; }
    // Decrement HEAP 'tickets' of winner and also the HEAP total in queue.
    // This changes the lottery distribution for future rounds.

    // Remove if finished or out of tickets
    if (w->size == 0 || w->tickets == 0) {
        printf("Removing P%d (%s).\n", w->pid,
               (w->size == 0) ? "finished work" : "no tickets left");
        remove_and_free(rq, w);
        // Unlink and free the winner if done or starved of tickets. After free, 'w' becomes invalid.
    }
}

// Start of main function, this is where the CPU starts working
//main stack frame. This is where the return value is declared and reserved as int
int main(void) {    
    srand((unsigned)time(NULL)); //
    // Seeds rand() with current epoch seconds; affects internal static RNG state.

    Queue q = {0};  //create new Q
    // 'q' is a Queue object on the STACK; fields zero-initialized:
    // q.first = NULL; q.totalTickets = 0; q.count = 0.

    int n;                                          // STACK int to hold number of processes.
    printf("Enter Number of processes: ");
    if (scanf("%d", &n) != 1 || n <= 0) { fprintf(stderr, "Invalid.\n"); return 1; }
    // scanf reads user input, writes into STACK 'n'. On failure or n<=0, exit with error code.

    for (int i = 1; i <= n; ++i) {
        int t, w;                                   // STACK ints for tickets and work for this process.
        printf("\nProcess %d - number of tickets: ", i);
        if (scanf("%d", &t) != 1 || t <= 0) return 1;
        printf("Process %d - work units:    ", i);
        if (scanf("%d", &w) != 1 || w <= 0) return 1;

        if (enqueue(&q, create_process(t, w)) != 0) {
            // create_process allocates a Process on the HEAP and returns its pointer;
            // enqueue links that HEAP node into the list represented by STACK 'q'.
            fprintf(stderr, "enqueue failed.\n");
            return 1;
        }
    }

    printf("\n=== Lottery start (UNITTIME     = %d) ===\n", UNITTIME);
    print_queue(&q);                                // Traverses HEAP list; prints fields; no memory mutations.

    for (int round = 1; q.count > 0; ++round) {     // 'round' lives on the STACK; loop while queue nonempty.
        lottery(&q, round);                         // Picks a winner, mutates HEAP node fields, may free nodes.
        print_queue(&q);                            // Prints current list after each round.
    }

    printf("\nAll processes completed.\n");
    return 0;  // Returning from main releases entire STACK frame; program ends.
}
